---
title: 数组与广义表（二）
date: 2020-12-14 16:51:05
tags:
---

# 广义表
## 定义
广义表是线性表的推广。也有人称其为列表。
**特点**：有深度，有长度，可递归，可共享
```
ADT Glist {

    数据对象：D＝｛ei | i=1,2,…,n; n>=0; ei属于AtomSet或ei 属于 GList，
                                      AtomSet为某个数据对象｝
    数据关系：R1＝｛<ei-1, ei> | ei-1, ei 属于D, 2 <= i <= n｝
    基本操作:    InitGList(&L);   
                DestroyGList(&L);  
                CopyGlist(&T,L);
                GListLength(L); 
                GListDepth(L);     
                GListEmpty(L); 
                GetHead(L);      
                GetTail(L);           
                InsertFirst_GL(&L, e)
                DeleteFirst_GL(&L, &e); 
                Traverse_GL(L, Visit());
}  ADT GList
```

## 广义表的存储结构
存在两种结构的结点（**表结点**和**原子结点**）
### 头尾链表存储
```
typedef enum {ATOM,LIST} ElemTag;   //ATOM=0:原子,LIST=1:子表
typedef struct GLNode{
    ElemTag tag;    //公共部分，用来区分原子结点和表结点
    Union{          //原子结点和表结点的联合部分
            AtomType atom;
            struct{ struct  GLNode *hp,*tp;}ptr;// 指针域,hp指向表头,tp指向表尾
        };
   }*Glist;

```
### 扩展线性链表存储
```
 typedef enum {ATOM,LIST}ElemTag; //ATOM==0:原子，LIST==1：子表
 typedef struct GLNode{
    ElemTag tag; //公共部分，用来区分原子结点和表结点
    Union{//原子结点和表结点的联合部分
        AtomType atom;//原子结点的值域
        Struct GLNode *hp//表结点的头指针
    };
    GLNode *tp; //指向下一个结点
}*Glist;

```
## 广义表应用递归（求表的深度）
递推模型：
````
LS=(a1,a2,····an)
DEPTH(LS)=0     LS是原子表
DEPTH(LS)=1     LS是空表
DEPTH(LS)=1+MAX(DEPTH(ai))    1<=i<=n   LS的一般情况
````
递归应用1--求深度函数实现
```
int GListDepth(Glist L)
{    
    if(!L)  return 1;
    if(L->tag==ATOM)    return 0; //是原子
    for(max=0,pp=L;pp;pp=pp->ptr.tp);
    {  
        dep=GListDepth(pp->ptr.hp);
        if(dep>max)     max=dep;
    }
    return max+1;
}//GListDepth
```
## 递归应用2--复制广义表
```
void GList_Copy(GList A,GList &B)// 复制广义表的递归算法 
{ 
    if(!A->tag) // 当结点为原子时 , 直接复制 
    {
        B->tag=0;     
        B->atom=A->atom;
    } 
    else // 当结点为子表时 
    {     
        B->tag=1; 
        if(A->ptr.hp) 
        {  
            B->ptr.hp=malloc(sizeof(GLNode)); 
            GList_Copy(A->ptr.hp,B->ptr.hp); 
        } // 复制表头 
        if(A->ptr.tp) 
        {       
            B->ptr.tp=malloc(sizeof(GLNode)); 
            GList_Copy(A->ptr.tp,B->ptr.tp); 
        } // 复制表尾 
    }//else 
}//GList_Copy 
```