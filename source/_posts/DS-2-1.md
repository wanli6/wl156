---
title: 栈与队列（一）
date: 2020-12-06 21:02:01
tags:
---
**栈**和**队列**实际上也是线性表，他们是操作受限的的线性表。 
# 栈
**栈**是限定在表尾进行插入或删除操作的的线性。表尾称为**栈顶**，相应的表头称为**栈底**。
所以栈是 后进先出(last in first out) 的线性表(**LIFO结构**)。
## 栈的抽象定义

    ADT Stack {
        数据对象：D＝{ai| ai∈ElemSet, i=1,2,...,n, n≥0 }
        数据关系：R1＝{ <ai-1,ai>| ,ai-1,ai∈D, i=2,...,n }
            约定an端为栈顶，a1端为栈底。
        基本操作：
        
        InitStack(&S)
            操作结果：构造一个空栈 S。
        DestroyStack(&S)
            初始条件：栈 S 已存在。
            操作结果：栈 S 被销毁。 
        ClearStack(&S)
            初始条件：栈 S 已存在。
            操作结果：将 S 清为空栈。
        StackEmpty(S)
            初始条件：栈 S 已存在。
            操作结果：若栈 S 为空栈，则返回TRUE，否则返回FALSE。
            判定栈是否为空栈是栈在应用程序中经常使用的操作，通常以它作为循环结束的条件。  
        StackLength(S)
            初始条件：栈 S 已存在。
            操作结果：返回栈 S 中元素个数，即栈的长度。
        GetTop(S, &e)
            初始条件：栈 S 已存在且非空。
            操作结果：用 e 返回S的栈顶元素。
            这是取栈顶元素的操作，只以 e 返回栈顶元素，并不将它从栈中删除。 
        Push(&S, e)
            初始条件：栈 S 已存在。
            操作结果：插入元素 e 为新的栈顶元素。
        Pop(&S, &e)
            初始条件：栈 S 已存在且非空。
            操作结果：删除 S 的栈顶元素，并用 e 返回其值。
        StackTraverse(S, visit( ))
            初始条件：栈 S 已存在且非空，visit( )为元素的访问函数。
            操作结果：从栈底到栈顶依次对S的每个元素调用函数visit( )，
        　　　　　　　　一旦visit( )失败，则操作失败。
    }