<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/DS-5-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/DS-5-3/" class="post-title-link" itemprop="url">选择排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-21 13:25:32 / Modified: 13:39:08" itemprop="dateCreated datePublished" datetime="2020-12-21T13:25:32+08:00">2020-12-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>简单快速排序</h1>
<p><strong>基本思想</strong>:选择类排序。每一次在n-i+1（i=1…n-1）个记录中选取关键字最小的记录作为有序序列的第i个记录。<br>
<strong>一趟排序</strong>：通过n-i次关键字的比较，从n-i+1个记录中选取关键字最小的记录与第i个记录交换。<br>
时间性能分析：O(n2)<br>
稳定性：不稳定</p>
<h1>树形选择排序</h1>
<p>从减少比较次数出发，降低时间复杂度<br>
<strong>树形选择排序(锦标赛排序)思想</strong>：先对n个记录的关键字两两比较，在「n/2个较小者之间再进行两两比较，重复直至选出最小关键字为止。<br>
<strong>时间复杂度</strong>:<code>O(nlog2n)</code><br>
<strong>小结</strong>：稳定的，辅助空间大，和最大值进行多余比较</p>
<h1>堆排序</h1>
<p><strong>堆排序</strong>：设堆中有n个元素，输出堆顶最大(小)值后，使剩余n-1元素重建成堆，得到n个元素的次大(小)值，反复执行，得到一个非递减(非递增)有序序列的过程。<br>
<strong>堆排序的步骤</strong><br>
Step1:将待排序记录关键字构成一棵完全二叉树；<br>
Step2:初始建堆(从最后一个非终端结点即无序序列中第  n/2个元素开始向前筛选(从堆顶到叶子结点的调整过程))，建成一个大顶堆；<br>
Step3:输出堆顶元素(与序列最后一个记录交换)，调整剩余元素为一个新堆。<br>
Step4:重复step3，直到排序结束<br>
所以：堆排序的时间复杂度为<code>O(nlog２n)</code><br>
<strong>小结</strong>：不稳定，适合于n较大的情况，需要一个记录大小供交换用的辅助存储空间</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/20/DS-5-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/20/DS-5-1/" class="post-title-link" itemprop="url">快速排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-20 23:03:10 / Modified: 23:30:54" itemprop="dateCreated datePublished" datetime="2020-12-20T23:03:10+08:00">2020-12-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>起泡排序</h1>
<p><strong>思想</strong>：交换排序，借助相邻元素的两两比较，出现逆序就交换<br>
<strong>过程</strong>：<br>
第一趟排序：从第1到第n个元素，若相邻两个元素位置逆序，交换；否则继续比较下面两个相邻元素，结果使关键字最大的记录被安置到第n个记录的位置上。<br>
第i趟排序：从第1到第n-i+1个元素，使n-i+1个关键字最大的记录被交换到第n-i+1个记录的位置上。每趟起泡排序，无序序列长度缩小1<br>
<strong>结束条件</strong>：在任何一趟排序过程中，未出现交换。<br>
<strong>效率分析</strong>:正序<code>O(n)</code>,逆序<code>O(n2)</code><br>
<strong>稳定性</strong>：稳定</p>
<h1>分区排序</h1>
<p><strong>基本思想</strong>：任选一个待排序序列中的关键字为基准，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均小于等于基准，另一部分都大于等于基准。分别对两个子序列进行快速排序，达到整个序列有序。<br>
<strong>一趟快速排序(一次划分)</strong>：<br>
待排序序列<code>{L.r[s],L.r[s+1],…,L.r[t]}</code>，选<code>L.r[s]</code>为枢轴，<br>
排序后 <code>{L.r[s],L.r[s+1],…,L.r[i-1]}</code>和<code>{L.r[i+1],L.r[i+2],…,L.r[t]}</code><br>
一趟快速排序过程：设指针<code>low=1,high=n</code>，<br>
Step1:从high所指位置起向前搜索找到第一个关键字小于枢轴的记录与枢轴交换，<br>
Step2:从low所指位置起向后搜索找到第一个关键字大于枢轴的记录与枢轴交换，<br>
Step3:重复这两步直到low=high为止。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/20/DS-5-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/20/DS-5-2/" class="post-title-link" itemprop="url">插入排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-20 22:49:42 / Modified: 23:03:31" itemprop="dateCreated datePublished" datetime="2020-12-20T22:49:42+08:00">2020-12-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>直接插入排序</h1>
<p><strong>思想</strong>：将一个记录插入到已排序的有序表，得到一个新的、记录数增1的有序表。<br>
<strong>过程</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Step1:查找R[i]的插入位置j+1；</span><br><span class="line">Step2:将R[j+1..i-1]中的记录后移一个位置；</span><br><span class="line">Step3:将R[i]复制到R[j+1]的位置上。</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong>：小结：稳定，在序列记录基本有序或n值较小时最佳  <code>O(n2)</code></p>
<h1>折半插入排序</h1>
<p><strong>思想</strong>:在有序表中，设<code>R[1..i-1]</code>是一个按关键字有序的序列，用折半查找确定<code>R[i]</code>在<code>R[1..i-1]</code>中的插入位置”<br>
<strong>过程</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Step1:用折半查找确定R[i]在R[1..i-1]中的插入位置”</span><br><span class="line">Step2:最后一个记录到插入位置的记录依次向后移动一个位置</span><br><span class="line">Step3:记录R[i]插入</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong>：稳定，适用于待排序记录数量很大的情况。 <code>O(n2)</code></p>
<h1>2-路插入排序</h1>
<p><strong>思想</strong>：另设一个与L.r同类型的数组d，令<code>d[1]=L.r[1]</code>，将<code>d[1]</code>看成排好序的序列中处于中间位置的记录。从L.r的第二个记录起依次与<code>d[1]</code>比较，若<code>L.r[i].key&lt;d[1].key</code>,插入到<code>d[1]</code>之前的有序表中，若<code>L.r[i].key&gt;d[1].key</code>,插入到<code>d[1]</code>之后的有序表中。<br>
<strong>优点</strong>：在折半插入排序基础上改进，减少了排序过程中移动记录的次数，为n2/8。<br>
<strong>缺点</strong>：<br>
不能绝对避免记录移动<br>
增加了记录的辅助空间,为n个。<br>
当<code>d[1]</code>为最大或最小关键字时，无优势可言。</p>
<h1>希尔排序</h1>
<p><strong>出发点</strong>：<br>
（1）若待排序的记录基本有序时，直接插入排序的效率可以大大提高；<br>
（2）n值很小时，效率也比较高。<br>
<strong>基本思想</strong>：将待排序记录序列分成若干子序列分别进行直接插入排序，待整个序列中记录“基本有序” 时，再对全体记录进行一次直接插入排序。<br>
<strong>特点</strong>:相隔某个增量的记录组成一个子序列。<br>
<strong>时间复杂度</strong>:是所取增量的函数， O（n3/2）<br>
<strong>稳定性</strong>：不稳定<br>
<strong>增量序列的选取</strong>:使增量序列中的值没有除1外的公因子，且最后一个增量必须是1。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/15/DS-4-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/DS-4-1/" class="post-title-link" itemprop="url">树与二叉树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-15 21:40:02" itemprop="dateCreated datePublished" datetime="2020-12-15T21:40:02+08:00">2020-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-16 22:10:31" itemprop="dateModified" datetime="2020-12-16T22:10:31+08:00">2020-12-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>树的定义与基本术语</h1>
<h2 id="树">树</h2>
<p>n（n≥0）个结点的有限集。在任一棵非空树中：</p>
<ol>
<li>有且仅有一个特定称为根的结点</li>
<li>n&gt;1时,其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2,…,Tn，Ti称为树的<strong>子树</strong>。<br>
树有<strong>递归性</strong>和<strong>层次性</strong>。</li>
</ol>
<h2 id="树的一些基本术语">树的一些基本术语</h2>
<p><strong>树的结点</strong>：数据元素及若干指向其子树的分支<br>
<strong>叶子</strong>（终端结点）：度（分支的个数）为零的结点<br>
<strong>非终端结点</strong>（分支结点）：度大于零的结点<br>
<strong>结点的度</strong>：分支的个数<br>
<strong>树的度</strong>：树中所有结点的度的最大值<br>
<strong>树的深度（高度）</strong>：树中叶子结点所在的最大层次<br>
<strong>结点的层次</strong>:设根结点的层次为1,第l层的结点子树根结点的层次为l+1</p>
<p><strong>孩子(结点)</strong>：结点子树的根称为该结点的孩子<br>
<strong>双亲(结点)</strong>：<br>
<strong>祖先(结点)</strong> ：从根到该结点所经分支上的所有结点。<br>
<strong>子孙(结点)</strong> ：以某结点为根的子树的任一结点<br>
<strong>兄弟(结点)</strong> ：同一双亲的孩子互称兄弟。<br>
<strong>堂兄弟(结点)</strong> ：其双亲在同一层的结点互称堂兄弟</p>
<p><strong>有序树</strong>：树中结点的各子树从左到右有次序(不能互换)。<br>
<strong>无序树</strong>：树中结点的各子树从左到右无次序(能互换)。<br>
<strong>森林</strong>：m（m≥0）棵互不相交的树的集合</p>
<h1>树的抽象数据结构定义</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ADT Tree &#123; </span><br><span class="line">    数据对象 D: D是具有相同特性的元素集合</span><br><span class="line">    数据关系R: 若D为空集, 则称空树;若D中只含一个数据元素,则R为空集,否则R&#x3D;&#123;H&#125;,H是如下二元关系:</span><br><span class="line">    (1)在D中存在惟一的称为根的数据元素root,它在关系H下无前驱;</span><br><span class="line">    (2)若D-&#123;root&#125;非空，则存在一个划分D1,D2,…,Dm(m&gt;0),对任意j!&#x3D;k(1&lt;&#x3D;j,k &lt;&#x3D;m)有Dj并Dk&#x3D;空集,且对任意的i (1&lt;&#x3D;i &lt;&#x3D;m),惟一存在数据元素xi属于Di, 有&lt;root, xi &gt; 属于H;</span><br><span class="line">    (3) 对应于D-&#123;root&#125;的划分，H－｛ &lt;root, x1 &gt; ，…, &lt;root, xm &gt; ｝有惟一的一个划分H1,H2,…,Hm(m&gt;0), 对任意j!&#x3D;k(1&lt;&#x3D;j,k &lt;&#x3D;m)有Hj 并 Hk&#x3D;空集,且对任意的i (1&lt;&#x3D;i &lt;&#x3D;m)， Hj是Di上的二元关系,（ Di ，｛ Hi ｝）是一棵符合本定义的树，称为根root的子树。</span><br><span class="line">    基本操作：</span><br><span class="line">            </span><br><span class="line">            InitTree(&amp;T); </span><br><span class="line">            DestroyTree(&amp;T); </span><br><span class="line">            CreateTree(&amp;T,definition); </span><br><span class="line">            ClearTree(&amp;T); </span><br><span class="line">            TreeEmpty(T); </span><br><span class="line">            TreeDepth(T); </span><br><span class="line">            Root(T); </span><br><span class="line">            Value(T,cur_e); </span><br><span class="line">            Assign(T, cur_e, value); </span><br><span class="line">            Parent(T, cur_e); </span><br><span class="line">            LeftChild(T,cur_e); </span><br><span class="line">            RightSibling(T,cur_e); </span><br><span class="line">            InsertChild(&amp;T,&amp;p,i,c); </span><br><span class="line">            DeleteChild(&amp;T,&amp;p,i); </span><br><span class="line">            TraverseTree(T,visit());</span><br><span class="line">   &#125; ADT Tree</span><br></pre></td></tr></table></figure>
<h1>二叉树</h1>
<p>学习二叉树的目的：</p>
<pre><code>二叉树操作算法简单
任何树都可与二叉树相互转换，
解决了树的存储结构及运算复杂性问题。
</code></pre>
<p>二叉树递归定义：由n(n&gt;=0)个结点的有限集合，或为空集，或由一个根结点及两棵互不相交的左右子树组成，并且左右子树都是二叉树。</p>
<h2 id="二叉树的抽象数据结构定义">二叉树的抽象数据结构定义</h2>
<p>暂时略</p>
<h2 id="二叉树的性质">二叉树的性质</h2>
<p>性质1：在二叉树的第i层上至多有<code>2i-1</code>个结点(i&gt;=1)。<br>
性质2：深度为k的二叉树至多有<code>2k－1个</code>结点（k&gt;=1).<br>
性质3：对任一棵二叉树，若其终端结点数为n0，度为2的结点数为n2，则<code>n0＝n2＋1</code>。<br>
性质4：具有n个结点的完全二叉树的深度为<code>[log2n] ＋1</code>。</p>
<h1>满二叉树与完全二叉树</h1>
<p>见ppt</p>
<h1>线索二叉树</h1>
<p>实质上是对二叉树中空的指针域的一种利用。<br>
线索存储方式与遍历的方式有关。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/14/code-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/14/code-5/" class="post-title-link" itemprop="url">code-5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-14 17:42:27 / Modified: 17:42:44" itemprop="dateCreated datePublished" datetime="2020-12-14T17:42:27+08:00">2020-12-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/14/DS-3-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/14/DS-3-2/" class="post-title-link" itemprop="url">数组与广义表（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-14 16:51:05 / Modified: 20:38:17" itemprop="dateCreated datePublished" datetime="2020-12-14T16:51:05+08:00">2020-12-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>广义表</h1>
<h2 id="定义">定义</h2>
<p>广义表是线性表的推广。也有人称其为列表。<br>
<strong>特点</strong>：有深度，有长度，可递归，可共享</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT Glist &#123;</span><br><span class="line"></span><br><span class="line">    数据对象：D＝｛ei | i&#x3D;1,2,…,n; n&gt;&#x3D;0; ei属于AtomSet或ei 属于 GList，</span><br><span class="line">                                      AtomSet为某个数据对象｝</span><br><span class="line">    数据关系：R1＝｛&lt;ei-1, ei&gt; | ei-1, ei 属于D, 2 &lt;&#x3D; i &lt;&#x3D; n｝</span><br><span class="line">    基本操作:    InitGList(&amp;L);   </span><br><span class="line">                DestroyGList(&amp;L);  </span><br><span class="line">                CopyGlist(&amp;T,L);</span><br><span class="line">                GListLength(L); </span><br><span class="line">                GListDepth(L);     </span><br><span class="line">                GListEmpty(L); </span><br><span class="line">                GetHead(L);      </span><br><span class="line">                GetTail(L);           </span><br><span class="line">                InsertFirst_GL(&amp;L, e)</span><br><span class="line">                DeleteFirst_GL(&amp;L, &amp;e); </span><br><span class="line">                Traverse_GL(L, Visit());</span><br><span class="line">&#125;  ADT GList</span><br></pre></td></tr></table></figure>
<h2 id="广义表的存储结构">广义表的存储结构</h2>
<p>存在两种结构的结点（<strong>表结点</strong>和<strong>原子结点</strong>）</p>
<h3 id="头尾链表存储">头尾链表存储</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;ATOM,LIST&#125; ElemTag;   &#x2F;&#x2F;ATOM&#x3D;0:原子,LIST&#x3D;1:子表</span><br><span class="line">typedef struct GLNode&#123;</span><br><span class="line">    ElemTag tag;    &#x2F;&#x2F;公共部分，用来区分原子结点和表结点</span><br><span class="line">    Union&#123;          &#x2F;&#x2F;原子结点和表结点的联合部分</span><br><span class="line">            AtomType atom;</span><br><span class="line">            struct&#123; struct  GLNode *hp,*tp;&#125;ptr;&#x2F;&#x2F; 指针域,hp指向表头,tp指向表尾</span><br><span class="line">        &#125;;</span><br><span class="line">   &#125;*Glist;</span><br></pre></td></tr></table></figure>
<h3 id="扩展线性链表存储">扩展线性链表存储</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> typedef enum &#123;ATOM,LIST&#125;ElemTag; &#x2F;&#x2F;ATOM&#x3D;&#x3D;0:原子，LIST&#x3D;&#x3D;1：子表</span><br><span class="line"> typedef struct GLNode&#123;</span><br><span class="line">    ElemTag tag; &#x2F;&#x2F;公共部分，用来区分原子结点和表结点</span><br><span class="line">    Union&#123;&#x2F;&#x2F;原子结点和表结点的联合部分</span><br><span class="line">        AtomType atom;&#x2F;&#x2F;原子结点的值域</span><br><span class="line">        Struct GLNode *hp&#x2F;&#x2F;表结点的头指针</span><br><span class="line">    &#125;;</span><br><span class="line">    GLNode *tp; &#x2F;&#x2F;指向下一个结点</span><br><span class="line">&#125;*Glist;</span><br></pre></td></tr></table></figure>
<h2 id="广义表应用递归（求表的深度）">广义表应用递归（求表的深度）</h2>
<p>递推模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LS&#x3D;(a1,a2,····an)</span><br><span class="line">DEPTH(LS)&#x3D;0     LS是原子表</span><br><span class="line">DEPTH(LS)&#x3D;1     LS是空表</span><br><span class="line">DEPTH(LS)&#x3D;1+MAX(DEPTH(ai))    1&lt;&#x3D;i&lt;&#x3D;n   LS的一般情况</span><br></pre></td></tr></table></figure>
<p>递归应用1–求深度函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int GListDepth(Glist L)</span><br><span class="line">&#123;    </span><br><span class="line">    if(!L)  return 1;</span><br><span class="line">    if(L-&gt;tag&#x3D;&#x3D;ATOM)    return 0; &#x2F;&#x2F;是原子</span><br><span class="line">    for(max&#x3D;0,pp&#x3D;L;pp;pp&#x3D;pp-&gt;ptr.tp);</span><br><span class="line">    &#123;  </span><br><span class="line">        dep&#x3D;GListDepth(pp-&gt;ptr.hp);</span><br><span class="line">        if(dep&gt;max)     max&#x3D;dep;</span><br><span class="line">    &#125;</span><br><span class="line">    return max+1;</span><br><span class="line">&#125;&#x2F;&#x2F;GListDepth</span><br></pre></td></tr></table></figure>
<h2 id="递归应用2–复制广义表">递归应用2–复制广义表</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void GList_Copy(GList A,GList &amp;B)&#x2F;&#x2F; 复制广义表的递归算法 </span><br><span class="line">&#123; </span><br><span class="line">    if(!A-&gt;tag) &#x2F;&#x2F; 当结点为原子时 , 直接复制 </span><br><span class="line">    &#123;</span><br><span class="line">        B-&gt;tag&#x3D;0;     </span><br><span class="line">        B-&gt;atom&#x3D;A-&gt;atom;</span><br><span class="line">    &#125; </span><br><span class="line">    else &#x2F;&#x2F; 当结点为子表时 </span><br><span class="line">    &#123;     </span><br><span class="line">        B-&gt;tag&#x3D;1; </span><br><span class="line">        if(A-&gt;ptr.hp) </span><br><span class="line">        &#123;  </span><br><span class="line">            B-&gt;ptr.hp&#x3D;malloc(sizeof(GLNode)); </span><br><span class="line">            GList_Copy(A-&gt;ptr.hp,B-&gt;ptr.hp); </span><br><span class="line">        &#125; &#x2F;&#x2F; 复制表头 </span><br><span class="line">        if(A-&gt;ptr.tp) </span><br><span class="line">        &#123;       </span><br><span class="line">            B-&gt;ptr.tp&#x3D;malloc(sizeof(GLNode)); </span><br><span class="line">            GList_Copy(A-&gt;ptr.tp,B-&gt;ptr.tp); </span><br><span class="line">        &#125; &#x2F;&#x2F; 复制表尾 </span><br><span class="line">    &#125;&#x2F;&#x2F;else </span><br><span class="line">&#125;&#x2F;&#x2F;GList_Copy</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/08/DS-3-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/08/DS-3-1/" class="post-title-link" itemprop="url">数组与广义表（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-08 22:54:20" itemprop="dateCreated datePublished" datetime="2020-12-08T22:54:20+08:00">2020-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-14 16:49:24" itemprop="dateModified" datetime="2020-12-14T16:49:24+08:00">2020-12-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>数组</h1>
<p>数组完成的操作较少，只有构造，销毁，取值，赋值。</p>
<h2 id="数组的数据结构定义">数组的数据结构定义</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT  Array &#123;</span><br><span class="line">	数据对象:ji&#x3D;0,…,bi – 1,  i &#x3D; 1,2,…,n, &#x2F;&#x2F;bi是数组第i维上的长度</span><br><span class="line">	        D&#x3D;&#123;aj1aj2···ajn|aj1aj2···ajn∈ElemSet &#125;</span><br><span class="line">	数据关系:R &#x3D; &#123;R1,R2,…,Rn&#125;</span><br><span class="line">		        Ri&#x3D;&#123;&lt;aj1···aji···aj,aj1···aji+1···ajn&gt;|0≤jk≤bk–1, 1≤k≤n,</span><br><span class="line">                k!&#x3D;i0≤ji≤bi–2,&lt;aj1···aji···aj,aj1···aji+1···ajn&gt;∈D, i&#x3D;2,3,…,n&#125;</span><br><span class="line">	基本操作：</span><br><span class="line">	InitArray(&amp;A,n,bound1,…,boundn)</span><br><span class="line">	DestroyArray(&amp;A)</span><br><span class="line">	Value(A,&amp;e,index1,…,indexn)</span><br><span class="line">	Assign(&amp;A,e,index1,…,indexn)	       </span><br><span class="line">&#125;ADT Array</span><br></pre></td></tr></table></figure>
<h2 id="数组的顺序存储">数组的顺序存储</h2>
<p>顺序存储的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType *base; &#x2F;&#x2F;数组元素基址</span><br><span class="line">    int dim;        &#x2F;&#x2F;数组维度</span><br><span class="line">    int *bounds;    &#x2F;&#x2F;数组维界基址</span><br><span class="line">    int *constants; &#x2F;&#x2F;数组映像函数常量基址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算数组任一元素的地址需要的三要素：</p>
<ol>
<li>数组的起始地址（即基地址）</li>
<li>数组维数和各维的长度；</li>
<li>数组中每个元素所占的存储单元</li>
</ol>
<p>已知二维数组A（b1,b2)，每个元素占L个存储单元， LOC(0,0)是数组第一个元素的起始地址，以行序为主存储，求LOC(i,j)。<br>
<strong>行主序：LOC(i,j) = LOC(0,0) + ( b2*i + j ) * L</strong><br>
<strong>列主序：LOC(i,j) = LOC(0,0) + ( b1*j + i ) * L</strong></p>
<h2 id="稀疏矩阵">稀疏矩阵</h2>
<h3 id="特殊矩阵-对称矩阵">特殊矩阵-对称矩阵</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      i(i+1)&#x2F;2+j  (i≥j)(存储下三角元素)</span><br><span class="line">k&#x3D;</span><br><span class="line">       j(j+1)&#x2F;2+i (i＜j)(存储上三角元素)</span><br></pre></td></tr></table></figure>
<h3 id="特殊矩阵-（上）下矩阵">特殊矩阵-（上）下矩阵</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下：</span><br><span class="line">    i*(i-1)&#x2F;2+j-1 (i≥j)</span><br><span class="line">k&#x3D;</span><br><span class="line">      n*(n+1)&#x2F;2      i＜j</span><br><span class="line">上：</span><br><span class="line">        (i-1) (2n-i+2)&#x2F;2+j-i (i≤j))</span><br><span class="line">k&#x3D;</span><br><span class="line">        n*(n+1)&#x2F;2      i&gt;j</span><br></pre></td></tr></table></figure>
<h3 id="特殊矩阵-对角矩阵">特殊矩阵-对角矩阵</h3>
<p>不在第一行的非零元ai,j，它前面已经存储了前i-1行元素为2+3(i-2)<br>
若ai,j是本行需第1个存储的元素(ai,i-1)，k=3(i-1)-1，(j=i+1)<br>
若ai,j是本行需第2个存储的元素(ai,i) ，k=3(i-1)，(i=j)<br>
若ai,j是本行需第3个存储的元素(ai,i+1) ，k=3(i-1)+1，(j=i+1)<br>
三式合并有<strong>k=2(i-1)+j-1</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status TransposeSMatrix(TSMatrix M,TSMatrix &amp;T)</span><br><span class="line">&#123;   T.mu&#x3D;M.nu;T.nu&#x3D;M.mu;T.tu&#x3D;M.tu;</span><br><span class="line">     if(T.tu)          &#x2F;&#x2F;tu非零元个数, mu行数， nu列数</span><br><span class="line">     &#123;   q&#x3D;1;</span><br><span class="line">          for(col&#x3D;1;col&lt;&#x3D;M.nu;++col)</span><br><span class="line">             for(p&#x3D;1;p&lt;&#x3D;M.tu;++p)</span><br><span class="line">              　if(M.data[q].j&#x3D;&#x3D;col)</span><br><span class="line">              　&#123;   T.data[q].i&#x3D;M.data[p].j; T.data[q].j&#x3D;M.data[p].i;</span><br><span class="line">               　   T.data[q].e&#x3D;M.data[p].e; ++q;&#125;   &#125;</span><br><span class="line">   return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;TransposeSMatrix</span><br></pre></td></tr></table></figure>
<h2 id="矩阵的压缩存储">矩阵的压缩存储</h2>
<h3 id="三元组顺序表">三元组顺序表</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;-----稀疏矩阵的三元顺序表存储表示-------</span><br><span class="line">#define MAXSIZE 12500   &#x2F;&#x2F;假设非零元个数的最大值</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int    i , j;     &#x2F;&#x2F;该非零元的行下标和列下标</span><br><span class="line">	ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	Triple data[MAXSIZE + 1];	&#x2F;&#x2F;非零元三元组表，data[0]未用</span><br><span class="line">	int   mu,nu,tu;				&#x2F;&#x2F;矩阵的行数、列数和非零元个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵的转置(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status TransposeSMatrix(TSMatrix M,TSMatrix &amp;T)</span><br><span class="line">&#123;   T.mu&#x3D;M.nu;T.nu&#x3D;M.mu;T.tu&#x3D;M.tu;</span><br><span class="line">     if(T.tu)          &#x2F;&#x2F;tu非零元个数, mu行数， nu列数</span><br><span class="line">     &#123;   q&#x3D;1;</span><br><span class="line">          for(col&#x3D;1;col&lt;&#x3D;M.nu;++col)</span><br><span class="line">             for(p&#x3D;1;p&lt;&#x3D;M.tu;++p)</span><br><span class="line">              　if(M.data[q].j&#x3D;&#x3D;col)</span><br><span class="line">              　&#123;   T.data[q].i&#x3D;M.data[p].j; T.data[q].j&#x3D;M.data[p].i;</span><br><span class="line">               　   T.data[q].e&#x3D;M.data[p].e; ++q;&#125;   &#125;</span><br><span class="line">   return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;TransposeSMatrix</span><br></pre></td></tr></table></figure>
<p><strong>评价</strong>:	O(nu*tu)，<br>
<strong>优点</strong>:	节省空间， <code>tu&lt;&lt;mu*nu</code>适用</p>
<p>矩阵的转置(2)–快速转置<br>
设<code>num</code>和<code>cpot</code>两个向量<br>
<code>num[col]</code> ：矩阵M的第col列中非零元素的个数，<br>
<code>cpot[col]</code>: 矩阵中第col列第一个非零元在T.data中的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpot[1]&#x3D;1;</span><br><span class="line">cpot[col]&#x3D;cpot[col-1]+num[col-1] (2&lt;&#x3D;col&lt;&#x3D;a.nu)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Status FastTransposeSMatrix(TSMatrix M,TSMatrix &amp;T)</span><br><span class="line">&#123;  T.mu&#x3D;M.nu;T.nu&#x3D;M.mu;T.tu&#x3D;M.tu;</span><br><span class="line">    if(T.tu) </span><br><span class="line">    &#123;  for(col&#x3D;1;col&lt;&#x3D;M.nu;++col) num[col]&#x3D;0;</span><br><span class="line">        for(t&#x3D;1;t&lt;&#x3D;M.tu;++t) ++num[M.data[t].j];&#x2F;&#x2F;求每列非零元个数</span><br><span class="line">        cpot[1]&#x3D;1;</span><br><span class="line">        for(col&#x3D;2;col&lt;&#x3D;M.nu;++col) </span><br><span class="line">              cpot[col]&#x3D;cpot[col-1]+num[col-1];</span><br><span class="line">        for(p&#x3D;1;p&lt;&#x3D;M.tu;++p) </span><br><span class="line">        &#123;   col&#x3D;M.data[p].j;q&#x3D;cpot[col];</span><br><span class="line">             T.data[q].i&#x3D;M.data[p].j; T.data[q].j&#x3D;M.data[p].i;</span><br><span class="line">             T.data[q].e&#x3D;M.data[p].e;++cpot[col];       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;&#x2F;&#x2F;TransposeSMatrix</span><br></pre></td></tr></table></figure>
<p>时间复杂度为<code>O(nu+tu)</code>,若<code>tu~mu*nu</code><br>
则为<code>O(mu*nu)</code>，与经典算法相同，多用了两个辅助向量。</p>
<h3 id="行逻辑链接的顺序表">行逻辑链接的顺序表</h3>
<p>需求：随机存取任一行的非0元<br>
方法：记住<code>Am*n</code>每一行第一个非0元在三元组表中的位置<br>
设数组<code>rpos[1..n]</code>:矩阵中的每行第一个非零元素的起始位置。<br>
　　　<code>rpos[1]=1</code>;<br>
rpos[row]=rpos[row-1]+第row-1行的非零元素个数<br>
行逻辑链接顺序表:在稀疏矩阵存储结构中固定指示行信息的辅助数组rpos</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-------行逻辑链接表存储结构的Ｃ语言描述--------</span><br><span class="line">typedef struct</span><br><span class="line">&#123;   Triple data[MAXSIZE+1]; 	&#x2F;&#x2F;非零元三元组表</span><br><span class="line">     int rpos[MAXRC+1];			&#x2F;&#x2F;各行第一个非零元素位置表</span><br><span class="line">     int mu,nu,tu;          	&#x2F;&#x2F;矩阵的行、列、非零元个数</span><br><span class="line">&#125;RLSMatrix</span><br></pre></td></tr></table></figure>
<p>稀疏矩阵相乘：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status MultSMarix (RLSMatrix&amp; M, RLSMatrix&amp; N, RLSMatrix&amp; Q)&#123;</span><br><span class="line">	if (M.nu !&#x3D; N.mu) 	return ERROR;</span><br><span class="line">	Q.mu&#x3D;M.mu;Q.NU&#x3D;N.nu;Q.tu&#x3D;0; &#x2F;&#x2F; Q初始化</span><br><span class="line">	if (M.tu*N.tu !&#x3D; 0) &#123;  &#x2F;&#x2F; Q是非零矩阵</span><br><span class="line">		for (arow&#x3D;1; arow&lt;&#x3D;M.mu; ++arow) &#123;	&#x2F;&#x2F; 处理M的每一行</span><br><span class="line">			ctemp[] &#x3D; 0;    &#x2F;&#x2F; 当前行各元素累加器清零</span><br><span class="line">			Q.rpos[arow] &#x3D; Q.tu+1;	&#x2F;&#x2F;设当前行第一个非零元在三元组表中的位序   </span><br><span class="line">			if(arrow&lt;M.mu)tp&#x3D;M.rpos[arrow+1];    </span><br><span class="line">			else tp&#x3D;M.tu+1;   </span><br><span class="line">		for (p&#x3D;M.rpos[arow]; p&lt;tp; ++p)	&#x2F;&#x2F; 对当前行中每一个非零元</span><br><span class="line">			brow&#x3D;M.data[p].j;  	&#x2F;&#x2F; 找到对应元在N中的行号</span><br><span class="line">			if (brow &lt; N.nu )  t &#x3D; N.rpos[brow+1];</span><br><span class="line">			else  &#123; t &#x3D; N.tu+1 &#125;  &#x2F;&#x2F; t指示该行中最后一个非零元的位置</span><br><span class="line">			for (q&#x3D;N.rpos[brow];  q&lt; t;  ++q) &#123;</span><br><span class="line">				ccol &#x3D; N.data[q].j;   	&#x2F;&#x2F; 乘积元素在Q中列号</span><br><span class="line">				ctemp[ccol] +&#x3D; M.data[p].e * N.data[q].e;     </span><br><span class="line">			&#125; &#x2F;&#x2F; for q</span><br><span class="line">		&#125; &#x2F;&#x2F; 求得Q中第crow( &#x3D;arow)行的非零元</span><br><span class="line">		for (ccol&#x3D;1; ccol&lt;&#x3D;Q.nu; ++ccol) 	&#x2F;&#x2F; 压缩存储该行非零元</span><br><span class="line">			if (ctemp[ccol]) &#123;  &#x2F;&#x2F; 该列元素为非零元</span><br><span class="line">				if (++Q.tu &gt; MAXSIZE)  return ERROR;</span><br><span class="line">				Q.data[Q.tu] &#x3D; &#123; arow, ccol, ctemp[ccol] &#125;;</span><br><span class="line">			&#125; &#x2F;&#x2F; if         </span><br><span class="line">		&#125; &#x2F;&#x2F; for arow     </span><br><span class="line">	&#125; &#x2F;&#x2F; if      </span><br><span class="line">	return OK;    </span><br><span class="line">&#125; &#x2F;&#x2F;MultSMatrix</span><br></pre></td></tr></table></figure>
<p>累加器ctemp初始化的时间复杂度为: <code>O(M.mu*N.mu)</code>，<br>
求Q的所有非零元的时间复杂度为:     <code>O(M.tu*N.tu/N.mu)</code>，<br>
进行压缩存储的时间复杂度为:            <code>O(M.mu*N.nu)</code>，<br>
总的时间复杂度: <code>O(M.mu*N.nu+M.tu*N.tu/N.mu)</code>。</p>
<h3 id="十字链表">十字链表</h3>
<p>当非零元个数和位置在操作过程中变化较大时，就不宜采用顺序存储结构，采用链式存储更恰当。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">存储结构的C语言描述</span><br><span class="line">typedef struct OLNode&#123;</span><br><span class="line">	int i,j;	&#x2F;&#x2F;行列下标</span><br><span class="line">	ElemType e;  </span><br><span class="line">	Struct OLNode *right,*down;	&#x2F;&#x2F;该非零元所在的行表和列表所在的链域</span><br><span class="line">&#125;OLNode,*OLink;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	OLink *rhead,*chead;	&#x2F;&#x2F;行和列链表头指针向量基址</span><br><span class="line">	int mu,nu,tu;	&#x2F;&#x2F;稀疏矩阵的行数，列数和非零元个数</span><br><span class="line">&#125;CrossLink;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/code-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/code-3/" class="post-title-link" itemprop="url">栈的操作函数（含测试）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-07 23:27:48 / Modified: 23:29:31" itemprop="dateCreated datePublished" datetime="2020-12-07T23:27:48+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define STACK_INIT_SIZE 100    &#x2F;&#x2F;初始分配空间</span><br><span class="line">#define STACKINCREMENT 10 &#x2F;&#x2F;存储空间分配增量</span><br><span class="line">#define SElemType int</span><br><span class="line">#define Status int</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    int stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建栈，栈长为预设值</span><br><span class="line">Status InitStack(SqStack &amp;S)      </span><br><span class="line">&#123;</span><br><span class="line">    S.base&#x3D;(SElemType*)malloc(STACK_INIT_SIZE*sizeof(SElemType));</span><br><span class="line">    if(!S.base) return ERROR;</span><br><span class="line">    S.top&#x3D;S.base;</span><br><span class="line">    S.stacksize&#x3D;STACK_INIT_SIZE;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;入栈</span><br><span class="line">Status Push(SqStack &amp;S,SElemType e)   </span><br><span class="line">&#123;</span><br><span class="line">    if(S.top-S.base&gt;&#x3D;S.stacksize)</span><br><span class="line">    &#123;</span><br><span class="line">        S.base&#x3D;(SElemType*)realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(SElemType));</span><br><span class="line">        if(S.base) return ERROR;</span><br><span class="line">        S.top&#x3D;S.base+S.stacksize;</span><br><span class="line">        S.stacksize+&#x3D;STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++&#x3D;e;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;删除栈顶元素</span><br><span class="line">Status Pop(SqStack &amp;S,SElemType &amp;e)   </span><br><span class="line">&#123;</span><br><span class="line">    if(S.top&#x3D;&#x3D;S.base) return ERROR;</span><br><span class="line">    e&#x3D;*--S.top;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;栈顶元素</span><br><span class="line">Status GetTop(SqStack S,SElemType &amp;e)   </span><br><span class="line">&#123;</span><br><span class="line">    if(S.top&#x3D;&#x3D;S.base) return ERROR;</span><br><span class="line">    e&#x3D;*(S.top-1);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;计算栈中元素个数</span><br><span class="line">int StackLength(SqStack S)   </span><br><span class="line">&#123;</span><br><span class="line">    int i&#x3D;0;</span><br><span class="line">    while(S.top!&#x3D;S.base)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        S.top--;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判空</span><br><span class="line">Status StackEmpty(SqStack S)&#123;</span><br><span class="line">    if(S.top&#x3D;&#x3D;S.base)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;置空</span><br><span class="line">Status ClearStack(SqStack &amp;S)&#123;</span><br><span class="line">    S.top&#x3D;S.base;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;销毁</span><br><span class="line">Status DestroyStack(SqStack &amp;S)&#123;</span><br><span class="line">    int len &#x3D; S.stacksize;</span><br><span class="line">    for(int i &#x3D;0; i &lt; len; i++)&#123;</span><br><span class="line">        free(S.base);</span><br><span class="line">        S.base++;</span><br><span class="line">    &#125;</span><br><span class="line">    S.base &#x3D; S.top &#x3D; NULL;</span><br><span class="line">    S.stacksize &#x3D; 0;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F;遍历栈</span><br><span class="line">Status StackTraverse(SqStack S)</span><br><span class="line">&#123;</span><br><span class="line">    SElemType *p&#x3D;(SElemType*)malloc(sizeof(SElemType));</span><br><span class="line">    p&#x3D;S.top;</span><br><span class="line"> </span><br><span class="line">    if(S.top&#x3D;&#x3D;S.base)</span><br><span class="line">        printf(&quot;The Stack is Empty!&quot;);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;The Stack is:&quot;);</span><br><span class="line">        while(p!&#x3D;S.base)</span><br><span class="line">        &#123;</span><br><span class="line">            p--;</span><br><span class="line">            printf(&quot;% d&quot;,*p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;主函数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    SqStack S;</span><br><span class="line">    SElemType x,e;</span><br><span class="line">    if(InitStack(S)) printf(&quot;A Stack Has Created.\n&quot;);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;1:Push\n2:Pop\n3:Get the Top\n4:Return the Length of the Stack\n5:Load the Stack\n0:Exit\nPlease choose:\n&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">        switch(a)</span><br><span class="line">        &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(!Push(S,x)) printf(&quot;Push Error!\n&quot;);</span><br><span class="line">            else printf(&quot;The Element %d is Successfully Pushed!\n&quot;,x);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            if(!Pop(S,e)) printf(&quot;Pop Error!\n&quot;);</span><br><span class="line">            else</span><br><span class="line"> </span><br><span class="line">                printf(&quot;The Element %d is Successfully Poped!\n&quot;,e);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            if(!GetTop(S,e)) printf(&quot;GetTop Error!\n&quot;);</span><br><span class="line">            else printf(&quot;The Top Element is %d!\n&quot;,e);</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            printf(&quot;The Length of the Stack is %d!\n&quot;,StackLength(S));</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">            StackTraverse(S);</span><br><span class="line">            break;</span><br><span class="line">        case 0:</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/code-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/code-4/" class="post-title-link" itemprop="url">队列操作函数的代码实现(含测试程序)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-07 21:18:31 / Modified: 23:25:37" itemprop="dateCreated datePublished" datetime="2020-12-07T21:18:31+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;队列操作实现</span><br><span class="line">&#x2F;&#x2F;单链队列---队列的链式存储结构</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">typedef int Status;</span><br><span class="line">typedef int QElemType;</span><br><span class="line"></span><br><span class="line">typedef struct QNode&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    QueuePtr front;&#x2F;&#x2F;队头</span><br><span class="line">    QueuePtr rear;&#x2F;&#x2F;队尾</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line">&#x2F;&#x2F;初始化队列</span><br><span class="line">Status InitQueue(LinkQueue &amp;Q)&#123;</span><br><span class="line">    Q.front&#x3D; Q.rear&#x3D;(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">    if(!Q.front) return ERROR;</span><br><span class="line">    Q.front-&gt;next&#x3D;NULL;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;销毁队列</span><br><span class="line">Status DestroyQueue(LinkQueue &amp;Q)&#123;</span><br><span class="line">    while(Q.front)&#123;</span><br><span class="line">        Q.rear&#x3D;Q.front-&gt;next;</span><br><span class="line">        free(Q.front);</span><br><span class="line">        Q.front&#x3D;Q.rear;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入</span><br><span class="line">Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p&#x3D;(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">    if(!p)  exit(0);</span><br><span class="line">    p-&gt;data&#x3D;e;</span><br><span class="line">    p-&gt;next&#x3D;NULL;</span><br><span class="line">    Q.rear-&gt;next&#x3D;p;</span><br><span class="line">    Q.rear&#x3D;p;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除</span><br><span class="line">Status DeQueue (LinkQueue &amp;Q,QElemType &amp;e)&#123;</span><br><span class="line">    QueuePtr q;</span><br><span class="line">    if(Q.front&#x3D;&#x3D;Q.rear) return ERROR;</span><br><span class="line">    q&#x3D;Q.front-&gt;next;</span><br><span class="line">    e&#x3D;q-&gt;data;</span><br><span class="line">    Q.front-&gt;next&#x3D;q-&gt;next;</span><br><span class="line">    if(Q.rear&#x3D;&#x3D;q) Q.rear &#x3D; Q.front;</span><br><span class="line">    free(q);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判空</span><br><span class="line">Status QueueEmpty(LinkQueue &amp;Q)&#123;</span><br><span class="line">    if(Q.rear&#x3D;&#x3D;Q.front)    return OK;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;清除队列</span><br><span class="line">Status ClearQueue(LinkQueue &amp;Q)&#123;</span><br><span class="line">    QElemType e;</span><br><span class="line">    while(!QueueEmpty(Q))  DeQueue(Q,e);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;队列长度</span><br><span class="line">int QueueLength(LinkQueue &amp;Q)&#123;</span><br><span class="line">    int length&#x3D;0;</span><br><span class="line">    QueuePtr p,q;</span><br><span class="line">    p&#x3D;Q.front;  q&#x3D;Q.rear;</span><br><span class="line">    while(p!&#x3D;q) &#123;</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取队头元素</span><br><span class="line">Status GetHead(LinkQueue &amp;Q, QElemType e)&#123;</span><br><span class="line">    e&#x3D;Q.front-&gt;next-&gt;data;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;遍历输出</span><br><span class="line">Status QueueTraverse(LinkQueue &amp;Q)&#123;</span><br><span class="line">    QueuePtr p,q;</span><br><span class="line">    QElemType e;</span><br><span class="line">    p&#x3D;Q.front;</span><br><span class="line">    while((p&#x3D;p-&gt;next)!&#x3D;Q.rear-&gt;next)&#123;</span><br><span class="line">        e&#x3D;p-&gt;data;</span><br><span class="line">        printf(&quot;%d  &quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">	EnQueue(Q, 1);</span><br><span class="line">	EnQueue(Q, 2);</span><br><span class="line">	EnQueue(Q, 3);</span><br><span class="line">	EnQueue(Q, 4);</span><br><span class="line">	EnQueue(Q, 5);</span><br><span class="line">	EnQueue(Q, 6);</span><br><span class="line">	EnQueue(Q, 7);</span><br><span class="line">	EnQueue(Q, 8);</span><br><span class="line">	EnQueue(Q, 9);</span><br><span class="line">	printf(&quot;链队列元素个数：%d\n&quot;,QueueLength(Q));</span><br><span class="line">	printf(&quot;展示元素：\n&quot;);</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line">	int e1, e2;</span><br><span class="line">	DeQueue(Q, e1);</span><br><span class="line">	DeQueue(Q, e2);</span><br><span class="line">	printf(&quot;删除元素：%d,%d\n&quot;, e1, e2);</span><br><span class="line">	printf(&quot;展示元素：\n&quot;);</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;链队列元素个数：%d\n&quot;, QueueLength(Q));</span><br><span class="line">	ClearQueue(Q);</span><br><span class="line">	printf(&quot;清空元素后，长度为%d，6rear &#x3D; %p，front&#x3D;%p&quot;,QueueLength(Q), Q.rear,Q.front);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/DS-2-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/DS-2-2/" class="post-title-link" itemprop="url">栈与队列（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-07 21:07:12" itemprop="dateCreated datePublished" datetime="2020-12-07T21:07:12+08:00">2020-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-14 16:48:42" itemprop="dateModified" datetime="2020-12-14T16:48:42+08:00">2020-12-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>队列</h1>
<p>和<strong>栈</strong>相反，<strong>队列</strong>是一种<strong>先进先出</strong>（first in first out,缩写<strong>FIFO</strong>)的线性表。它只允许在表的一端进行插入，另一端删除元素。</p>
<h2 id="队列的抽象数据类型定义">队列的抽象数据类型定义</h2>
<pre><code>ADT Queue{

数据对象：D={ai|ai∈ElemSet, i=1,2, …,n, n≥0}

数据关系：R1={&lt;ai-1,ai&gt;|ai-1,ai∈D, i=1,2, …,n}
约定a1为队列头，an为队列尾。

基本操作：

    InitQueue( &amp;Q )
    操作结果：构造一个空队列Q。
    DestroyQueue ( &amp;Q )
    初始条件：队列Q已存在。
    操作结果：销毁队列Q。
    ClearQueue ( &amp;Q )
    初始条件：队列Q已存在。
    操作结果：将Q清为空队列。
    QueueEmpty( Q )
    初始条件：队列Q已存在。
    操作结果：若Q为空队列，则返回TRUE，否则返回FALSE。
    QueueLength( Q )
    初始条件：队列Q已存在。
    操作结果：返回Q的数据元素个数，即队列的长度。
    GetHead( Q, &amp;e )
    初始条件：队列Q已存在且非空。
    操作结果：用e返回Q的队头元素。
    EnQueue( &amp;Q, e )
    初始条件：队列Q已存在。
    操作结果：插入元素e为Q的新的队尾元素。
    DeQueue( &amp;Q, &amp;e )
    初始条件：队列Q已存在且非空。
    操作结果：删除Q的队头元素，并用e返回其值。
    QueueTraverse( Q, visit() )
    初始条件：队列Q已存在且非空。
    操作结果：从队头到队尾依次对Q的每个数据元素调用函数visit()。一旦visit()失败，则操作失败。
}ADT Queue</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wanli6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wanli6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
